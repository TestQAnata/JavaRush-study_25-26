package JavaSyntax.ModuleOne.Theory_JR.Function;

public class Modifications {
    //Перед каждым методом программист может указать так называемые модификаторы доступа. К ним относятся ключевые слова: public, protected, private.

//    Эти «модификаторы доступа» позволяют ограничивать доступ к методу из других классов.
//
//    Например, если перед объявлением метода написать ключевое слово private, этот метод можно будет вызывать только из того же класса, в котором он объявлен. Ключевое слово public разрешает обращение к помеченному методу из любого метода любого класса.
//
//    Всего таких модификаторов 3, а типов доступа к методу — 4, ведь отсутствие модификатора доступа тоже что-то значит.

//   1. Модификатор public.
//К методу (переменной или классу), помеченному модификатором public, можно обращаться из любого места программы. Это самая высокая степень открытости – никаких ограничений нет.
    //Доступ из:
    // - Любого класса
    // - Класса - наследника
    // - Своего пакета
    // - Своего класса

//   2. Модификатор private.
// К методу (переменной или классу), помеченному модификатором private, можно обращаться только из того же класса, где он объявлен. Для всех остальных классов помеченный метод (или переменная) – невидимы и «как бы не существуют». Это самая высокая степень закрытости — только свой класс.
    //Доступ из:
    // - Своего класса

//  3. Без модификатора (модификатор по умолчанию).
// Если метод (или переменная) не помечены никаким модификатором, считается, что они помечены «модификатором по умолчанию». Переменные или методы с таким модификатором (т.е. вообще без какого-нибудь) видны всем классам пакета, в котором они объявлены. И только им. Этот модификатор еще иногда называют package, намекая, что доступ к переменным и методам открыт для всего пакета, в котором находится их класс
    //Доступ из:
    // - Своего пакета
    // - Своего класса

// 4.  4. Модификатор protected.
//Если метод помечен модификатором protected, к нему можно обращаться из того же класса, того же пакета и классов наследников (классов, унаследованных от класса, в котором объявлен метод).
    // - Класса - наследника
    // - Своего пакета
    // - Своего класса

// Ключевое слово static
// превращает метод в статический.
// Факт 1. Статический метод не привязан ни к какому объекту, но относится к классу, в котором объявлен.
    //ИмяКласса.имяМетода()
    //Например:
    //Thread.sleep()//Thread - имя класса, sleep() - имя метода
    //Math.abc()//Math - имя класса, abc() - имя метода
    //Arrays.sort()// Arrays - имя класса, sort() - имя метода

    //Имя класса перед именем статического метода можно не писать, если вы вызываете статический метод изнутри — из того же класса.

// Факт 2. Статический метод не может обращаться к нестатическим методам его же класса.
    //Статический метод может обращаться только к статическим методам. Поэтому все методы, которые мы хотим вызвать из метода main, мы объявляем статическими.


//Ключевое слово throws
    //public static тип имя(параметры) throws Exception
    //{
    //   код метода
    //}


//  Метод main
    //Строка, в которой объявляется метод, со всеми модификаторами, будет влиять на то, как этот метод будет вызываться из других классов и методов. Результат какого типа он будет возвращать и какие возможны ошибки при его работе.
    //
    //Такая строка называется объявлением метода и имеет общий вид:

    //модификаторы доступа static тип имя(параметры) throws исключения
    //модификаторы доступа — это public, protected, private или ничего;
    //static ставится, если метод статический (отсутствует для нестатических методов)
    //тип — тип результата функции (void если результат отсутствует)




}
